/**
 * @file encoder.c
 *
 * @brief Functions for ???
 *
 */

#include <asf.h>
#include <encoder.h>
#include <encoder_quad_linear.h>
#include <encoder_abs_index_linear.h>
#include <encoder_abs_biss_linear.h>
#include <encoder_abs_magnetic_rotation.h>
#include <stepper.h>
#include <cpld.h>
#include <pins.h>
#include <string.h>
#include <delay.h>
#include "helper.h"

// TODO temp
int32_t Debug_new_counts = 0;
int32_t Debug_t = 0;


/****************************************************************************
 * Private Data
 ****************************************************************************/

/****************************************************************************
 * Function Prototypes
 ****************************************************************************/
static int32_t average_filter(Encoder *enc, int32_t new_counts, int32_t max_counts);

/****************************************************************************
 * Interrupt Handler
 ****************************************************************************/

/****************************************************************************
 * Private Functions
 ****************************************************************************/
static int32_t average_filter(Encoder *enc, int32_t new_counts, int32_t max_counts)
{
	uint8_t filter_coef = 0;
	int32_t enc_pos = enc->enc_pos_prev_raw;
	uint32_t delta = abs(new_counts - enc_pos);
	Debug_new_counts = new_counts;

	// check for wrap around
	if(delta > max_counts)
	{
		delta = max_counts - delta;

		if(new_counts  > max_counts)
		{
			enc_pos = max_counts - enc_pos;
		}
		else
		{
			enc_pos = new_counts - (max_counts - enc_pos);
		}
	}

	if(delta < 40)
	{
		filter_coef = 20;
	}
	else if(delta < 100)
	{
		filter_coef = 4;
	}
	else
	{
		filter_coef = 0;
	}

	int32_t temp = (new_counts + (enc_pos * filter_coef));
	float t = temp / (filter_coef + 1);

	/* Store this raw value to compute the delta next time*/
	enc->enc_pos_prev_raw = (int32_t) t;

	return (int32_t) t;
}

/****************************************************************************
 * Public Functions
 ****************************************************************************/
int32_t convert_signed32_to_twos_comp(int32_t value)
{
	if (value < 0)
		return value + 4194304;
	else
		return value;
}

int32_t convert_twos_comp_to_signed32(uint32_t value)
{
	int32_t temp;

	if (value >> 21)
		temp = value | 0xFFC00000;
	else
		temp = value;
	return temp;
}

void set_encoder_position(uint8_t slot, uint8_t encoder_flags, Encoder *enc, int32_t counts)
{
	/* if counting is reversed multiple by -1*/
	if (encoder_flags & ENCODER_REVERSED)
		counts *= -1;

	int32_t counts_in_twos_format = 0;

	switch (enc->type)
	{
		case ENCODER_TYPE_NONE:
			break;

		case ENCODER_TYPE_QUAD_LINEAR:
#if ENABLE_STEPPER_POS_32BIT_TEST
//			counts_in_twos_format = convert_signed32_to_twos_comp(counts);
			counts_in_twos_format = counts;
#else
			counts_in_twos_format = counts;
#endif
			set_quad_linear_encoder_position(slot, counts_in_twos_format);
			enc->enc_pos = counts;
			// for quad copy the value to enc_pos_raw because it is used elsewhere
			enc->enc_pos_raw = counts;
			break;

		case ENCODER_TYPE_ABS_INDEX_LINEAR:
			counts_in_twos_format = convert_signed32_to_twos_comp(counts);
			set_quad_linear_encoder_position(slot, counts_in_twos_format);
			enc->enc_pos = counts;
			// for quad copy the value to enc_pos_raw because it is used elsewhere
			enc->enc_pos_raw = counts;
			break;

		case ENCODER_TYPE_ABS_BISS_LINEAR:
			enc->enc_zero = enc->enc_pos_raw + counts;
			enc->enc_pos = enc->enc_pos_raw - enc->enc_zero;
			break;

		case ENCODER_TYPE_ABS_MAGNETIC_ROTATION:
		case ENCODER_TYPE_ABS_MAGNETIC_ROTATION_AUTO_HOME:
			set_abs_magnetic_rotation_encoder_position(slot, counts_in_twos_format);
			break;

		default:
			break;
	}
}

/**
 * @brief Reads the encoder counts from the CPLD.  The count register is 22 bits.
 * @param slot
 * @param encoder : These are where encoder flags are stored
 * @param enc : Pointer to encoder structure
  */
void get_encoder_counts(uint8_t slot, uint8_t encoder_flags, uint32_t max_pos, Encoder *enc)
{
	uint32_t counts;
	int32_t counts_in_twos_format;

	switch (enc->type)
	{
		case ENCODER_TYPE_NONE:
			break;

		case ENCODER_TYPE_QUAD_LINEAR:
#if ENABLE_STEPPER_POS_32BIT_TEST
			counts = get_quad_linear_encoder_counts(slot);
			counts_in_twos_format = convert_twos_comp_to_signed32(counts);
			enc->enc_pos = counts_in_twos_format;
			enc->enc_pos_raw = enc->enc_pos;
#else
			counts = get_quad_linear_encoder_counts(slot);
			counts_in_twos_format = convert_twos_comp_to_signed32(counts);
			enc->enc_pos = counts_in_twos_format;
			enc->enc_pos_raw = enc->enc_pos;
#endif
			break;

		case ENCODER_TYPE_ABS_INDEX_LINEAR:
//			counts = get_abs_index_linear_encoder_counts(slot);
			counts = get_quad_linear_encoder_counts(slot);
			counts_in_twos_format = convert_twos_comp_to_signed32(counts);
			enc->enc_pos = counts_in_twos_format;
			enc->enc_pos_raw = enc->enc_pos;
			break;

		case ENCODER_TYPE_ABS_BISS_LINEAR:
			enc->enc_pos_raw = get_abs_biss_linear_encoder_counts(slot, enc);
			enc->enc_pos = enc->enc_pos_raw - enc->enc_zero;

break;

		case ENCODER_TYPE_ABS_MAGNETIC_ROTATION:
		case ENCODER_TYPE_ABS_MAGNETIC_ROTATION_AUTO_HOME:
			/*Counts go up in CCW direction*/
			counts = get_abs_magnetic_rotation_encoder_counts(slot, enc);
			enc->enc_pos_raw = average_filter(enc, counts, max_pos);


			/* Calculate enc_pos from offset.  Because it is rotational we have to check if the
			 * offset is in the wrap around region*/
			if(enc->enc_pos_raw < enc->enc_zero)	/*Wrap around region*/
			{
				enc->enc_pos =  max_pos - (enc->enc_zero - enc->enc_pos_raw);
			}
			else
				enc->enc_pos = enc->enc_pos_raw - enc->enc_zero;
			break;

		default:
			break;
	}

	/* if counting is reversed multiple by -1*/
	if (encoder_flags & ENCODER_REVERSED)
		enc->enc_pos *= -1;
}

/**
 * @brief Setup the encoder for this slot
 * @param slot
 * @param encoder_flags
 * @param enc
 */
void setup_encoder(uint8_t slot, uint8_t encoder_flags, uint32_t max_pos, Encoder *enc)
{
	enc->error = 0;
	enc->warn = 0;
	enc->mhi = 0;
	enc->mlo = 0;
	enc->m_ready = 1;

	if (Tst_bits(encoder_flags, HAS_ENCODER))
	{
		switch (enc->type)
		{
			case ENCODER_TYPE_NONE:
				break;

			case ENCODER_TYPE_QUAD_LINEAR:
				/*Disable encoder zero on limit mode*/
				set_reg(C_SET_HOMING, slot, 0, (uint32_t)C_HOMING_DISABLE);
				set_encoder_position(slot, encoder_flags, enc, enc->enc_pos);
				break;

			case ENCODER_TYPE_ABS_INDEX_LINEAR:
				set_reg(C_SET_HOMING, slot, 0, (uint32_t)C_HOMING_DISABLE);
				set_encoder_position(slot, encoder_flags, enc, enc->enc_pos);
				enc->homed = false;
				break;

			case ENCODER_TYPE_ABS_BISS_LINEAR:
				break;

			case ENCODER_TYPE_ABS_MAGNETIC_ROTATION:
			case ENCODER_TYPE_ABS_MAGNETIC_ROTATION_AUTO_HOME:
				/*If the encoder has an optical switch to index, enable this mode
				 * in the CPLD*/
//				set_reg(C_SET_ENABLE_STEPPER_CARD, slot, 0, DIGITAL_OUTPUT);
//				set_reg(C_SET_ENABLE_STEPPER_CARD, slot, 0, 0);
//				set_reg(C_SET_ENABLE_STEPPER_CARD, slot, 0, 1);
//				set_reg(C_SET_ENABLE_STEPPER_CARD, slot, 0, 2);
//				set_reg(C_SET_ENABLE_STEPPER_CARD, slot, 0, 3);
//				set_reg(C_SET_STEPPER_DIGITAL_OUTPUT, slot, 0, 1);
//				set_reg(C_SET_STEPPER_DIGITAL_OUTPUT, slot, 0, 0);//etic sensor

				get_encoder_counts(slot, encoder_flags,	max_pos, enc);
				vTaskDelay(pdMS_TO_TICKS(2));
				get_encoder_counts(slot, encoder_flags,	max_pos, enc);
				vTaskDelay(pdMS_TO_TICKS(2));
				get_encoder_counts(slot, encoder_flags,	max_pos, enc);
				enc->homed = false;
				break;

			default:
				break;
		}

	}
}

